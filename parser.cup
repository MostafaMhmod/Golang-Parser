import java.io.*;

	
/* Terminals (tokens returned by the scanner). */
terminal			BREAK, DEFAULT, FUNC, CASE, STRUCT, ELSE, PACKAGE, SWITCH, CONST, IF, 
					TYPE, FOR, IMPORT, RETURN, VAR, OR_OP, AND_OP, PLUS, MINUS, OPEN_PARAN, 
					CLOSE_PARAN, OPEN_CURLY, CLOSE_CURLY, OPEN_SQUARE, CLOSE_SQUARE, 
					SEMI_COLON, COMMA, DOT, COLON, COLON_EQUAL, EQUAL, CDOTS, ASTRISK, 
					SHIFT_LEFT, SHIFT_RIGHT, BAR, SLASH, EXCLAMATION, LESS_DASH, AMBERSAND,
					PERCENT, INCREMENT, DECREMENT;
terminal	String	IDENTIFIER, REL_OP, STRING_LIT, INT_LIT;	

/* Non-terminals */
nonterminal String	sourceFile, packageClause, importDecls, importDecl,
					topLevelDecl, packageName, importSpecs, importSpec, importPath, 
					optionalSemiColon, declaration, functionDecl, methodDecl, 
					constDecl, varDecl, constSpec, identifierList, 
					expressionList, primaryExpr, 
					unaryExpr, operand, selector,
					arguments, literal, operandName, basicLit, functionLit, 
					qualifiedIdent, function, signature, functionBody, parameters, result, 
					type, parameterList, parameterDecl, block, statementList, statement, 
					typeName, typeLit, functionType, varSpec, shortVarDecl, functionName, 
					methodName, receiver, simpleStmt, returnStmt, breakStmt, 
					ifStmt, switchStmt, forStmt, expressionStmt, incDecStmt, assignment, 
					exprSwitchStmt, initStmt, postStmt, condition, forClause, 
					exprCaseClauses, exprCaseClause, exprSwitchCase;


nonterminal Express expression  ;
/*precedence left COMMA;
precedence left OR_OP;
precedence left AND_OP;
precedence left REL_OP;
precedence left PLUS, MINUS, BAR;
precedence left ASTRISK, SLASH, PERCENT, SHIFT_LEFT, SHIFT_RIGHT, AMBERSAND;*/

precedence left OR_OP, AND_OP, REL_OP;
precedence left PLUS, MINUS, BAR;
precedence left ASTRISK, SLASH, SHIFT_LEFT, SHIFT_RIGHT, PERCENT, AMBERSAND;
precedence left EXCLAMATION, LESS_DASH;
precedence left OPEN_PARAN, CLOSE_PARAN;
precedence left COMMA, SEMI_COLON;
precedence left COLON;

start with sourceFile;

/* The grammar */
sourceFile	::=	packageClause:a optionalSemiColon:b importDecls:c topLevelDecl:d
				{:
				RESULT = a+b+c+d;
				:}
				| packageClause:a optionalSemiColon:b importDecls:c
				{:
				RESULT = a+b+c;
				:};

// TopLevelDecl = Declaration | FunctionDecl [ ​";" ​ ] | MethodDecl [ ​";" ​ ]
topLevelDecl	::=	declaration:d 
					{:
					RESULT = d;
					:}
					| functionDecl:d optionalSemiColon:o
					{:
					RESULT = d+o;
					:}
					| methodDecl:m optionalSemiColon:o
					{:
					RESULT = m+o;
					:};

// Declaration = ConstDecl ​";" ​ | VarDecl ​";"
declaration	::=	constDecl:c SEMI_COLON
				{:
				RESULT = c+";";
				:}
				| varDecl:v SEMI_COLON
				{:
				RESULT = v+";";
				:};

// ConstDecl = ​"const" ​ ( ConstSpec | ​"(" ​ { ConstSpec ​";" ​ } ​")" ​ )
constDecl	::=	CONST constSpec:c
				{:
				RESULT = "const"+ c;
				:}
				| CONST OPEN_PARAN constSpec:c CLOSE_PARAN
				{:
				RESULT = "const"+"("+c+")";
				:}
				| CONST OPEN_PARAN CLOSE_PARAN
				{:
				RESULT = "const"+ "("+")";
				:};

// ConstSpec = ​identifier ​ [ [ Type ] ​"=" ​ Expression ]
constSpec	::=	IDENTIFIER:i
				{:
				RESULT = i;
				:}
				| IDENTIFIER:i EQUAL expression:e
				{:
				RESULT = i+"="+e.code;
				:}
				| IDENTIFIER:i type:t EQUAL expression:e
				{:
				RESULT = i+t+"="+e.code;
				:};
				
// Statement = Declaration | SimpleStmt ​";" ​| ReturnStmt ​";" ​ | BreakStmt ​";" ​ | Block [ ​";" ​] | IfStmt [ ​";" ​]
// | SwitchStmt [ ​";" ] ​| ForStmt [ ​";" ​]
statement	::=	declaration:d
				{:
				RESULT = d;
				:}
				| simpleStmt:s SEMI_COLON
				{:
				RESULT = s+";";
				:}
				| returnStmt:r SEMI_COLON
				{:
				RESULT = r+";";
				:}
				| breakStmt:b SEMI_COLON
				{:
				RESULT = b+";";
				:}
				| block:b optionalSemiColon:o
				{:
				RESULT = b+o;
				:}
				| ifStmt:i optionalSemiColon:o
				{:
				RESULT = i+o;
				:}
				| switchStmt:s optionalSemiColon:o
				{:
				RESULT = s+o;
				:}
				| forStmt:f optionalSemiColon:o
				{:
				RESULT = f+o;
				:};

// SimpleStmt = ExpressionStmt | IncDecStmt | Assignment | ShortVarDecl
simpleStmt	::= expressionStmt:e
				{:
				RESULT = e;
				:}
				| incDecStmt:i
				{:
				RESULT = i;
				:}
				| assignment:a
				{:
				RESULT = a;
				:}
				| shortVarDecl:s
				{:
				RESULT = s;
				:};

// ExpressionStmt = Expression
expressionStmt	::= expression:e
					{:
					RESULT = e.code;
					:};

// IncDecStmt = Expression ( ​"++" ​ | ​"--" ​ )
incDecStmt	::= expression:e INCREMENT:i
				{:
				RESULT = e.code+"++";
				:}
				| expression:e DECREMENT:d
				{:
				RESULT = e.code+"--";
				:};

// Assignment = ExpressionList [ ​"+" ​ | ​"-" ​| ​"*" ​ | ​"/" ​ | ​"<<" ​ | ​">>" ​] ​"=" ​ ExpressionList
assignment	::=	expressionList:e1 PLUS EQUAL expressionList:e2
				{:
				RESULT = e1+"+"+"="+e2;
				:}|
				expressionList:e1 MINUS EQUAL expressionList:e2
				{:
				RESULT = e1+"-"+"="+e2;
				:}|
				expressionList:e1 BAR EQUAL expressionList:e2
				{:
				RESULT = e1+"|"+"="+e2;
				:}|
				expressionList:e1 ASTRISK EQUAL expressionList:e2
				{:
				RESULT = e1+"*"+"="+e2;
				:}|
				expressionList:e1 SLASH EQUAL expressionList:e2
				{:
				RESULT = e1+"/"+"="+e2;
				:}|
				expressionList:e1 SHIFT_LEFT EQUAL expressionList:e2
				{:
				RESULT = e1+"<<"+"="+e2;
				:}|
				expressionList:e1 SHIFT_RIGHT EQUAL expressionList:e2
				{:
				RESULT = e1+">>"+"="+e2;
				:}|
				expressionList:e1 PERCENT EQUAL expressionList:e2
				{:
				RESULT = e1+"%"+"="+e2;
				:}|
				expressionList:e1 AMBERSAND EQUAL expressionList:e2
				{:
				RESULT = e1+"&"+"="+e2;
				:}|
				expressionList:e1 EQUAL expressionList:e2
				{:
				RESULT = e1+"="+e2;
				:};



ifStmt	::=	IF expression block
			{:
			RESULT = "";
			:}
			| IF simpleStmt SEMI_COLON expression block
			{:
			RESULT = "";
			:}
			| IF expression block ELSE ifStmt
			{:
			RESULT = "";
			:}
			| IF expression block ELSE block
			{:
			RESULT = "";
			:}
			| IF simpleStmt SEMI_COLON expression block ELSE ifStmt
			{:
			RESULT = "";
			:}
			| IF simpleStmt SEMI_COLON expression block ELSE block
			{:
			RESULT = "";
			:};


switchStmt	::=	exprSwitchStmt
				{:
				RESULT = "";
				:};


exprSwitchStmt	::= SWITCH OPEN_CURLY exprCaseClauses CLOSE_CURLY
					{:
					RESULT = "";
					:}
					| SWITCH  simpleStmt SEMI_COLON OPEN_CURLY exprCaseClauses CLOSE_CURLY
					{:
					RESULT = "";
					:}
					| SWITCH expression OPEN_CURLY exprCaseClauses CLOSE_CURLY
					{:
					RESULT = "";
					:}
					| SWITCH simpleStmt SEMI_COLON expression OPEN_CURLY exprCaseClauses CLOSE_CURLY
					{:
					RESULT = "";
					:};


exprCaseClauses	::=	exprCaseClause exprCaseClauses
					{:
					RESULT = "";
					:}
					| 
					{:
					RESULT = "";
					:};

exprCaseClause	::= exprSwitchCase COLON statementList
					{:
					RESULT = "";
					:};

exprSwitchCase	::=	CASE expressionList
					{:
					RESULT = "";
					:}
					| DEFAULT
					{:
					RESULT = "";
					:};


forStmt	::=	FOR block
			{:
			RESULT = "";
			:}
			| FOR condition block
			{:
			RESULT = "";
			:}
			| FOR forClause block
			{:
			RESULT = "";
			:};


forClause	::=	initStmt SEMI_COLON condition SEMI_COLON postStmt
				{:
				RESULT = "";
				:}
				| SEMI_COLON condition SEMI_COLON postStmt
				{:
				RESULT = "";
				:}
				| initStmt SEMI_COLON SEMI_COLON postStmt
				{:
				RESULT = "";
				:}
				| initStmt SEMI_COLON condition optionalSemiColon
				{:
				RESULT = "";
				:}
				| SEMI_COLON SEMI_COLON postStmt
				{:
				RESULT = "";
				:}
				| SEMI_COLON condition optionalSemiColon
				{:
				RESULT = "";
				:}
				| initStmt SEMI_COLON optionalSemiColon
				{:
				RESULT = "";
				:}
				| SEMI_COLON optionalSemiColon
				{:
				RESULT = "";
				:};


condition	::=	expression
				{:
				RESULT = "";
				:};

initStmt	::=	simpleStmt
				{:
				RESULT = "";
				:};


postStmt	::=	simpleStmt
				{:
				RESULT = "";
				:};


returnStmt	::=	RETURN
				{:
				RESULT = "";
				:}
				| RETURN expressionList
				{:
				RESULT = "";
				:};


breakStmt	::=	BREAK
				{:
				RESULT = "";
				:};


// IdentifierList = ​identifier ​ { ​"," identifier ​ }
identifierList	::=	IDENTIFIER:i
					{:
					RESULT = i;
					:}
					| IDENTIFIER:i COMMA:c identifierList:l
					{:
					RESULT = i+c+l;
					:};

// ExpressionList = Expression { ​"," ​ Expression }
expressionList	::=	expression:e
					{:
					RESULT = e.code;
					:}
					| expression:e COMMA expressionList:l
					{:
					RESULT = e.code+":"+l;
					:};


expression	::=	unaryExpr:u
				{:
				RESULT  =  new Express();
				// RESULT.code  = u ;
				// Express x  =  new Express();
				// x.setCode(u);
				// RESULT=x;
				:}
				| expression:a REL_OP:r expression:b
				{:
				RESULT= new Express(a,r,b);
				// RESULT  =  new Express();
				// RESULT.code = a.code+""+b.code+RESULT.address+"="+a.address + r + b.address;
				RESULT.address = Express.Temp();
				:}
				| expression:a OR_OP expression:b
				{:
				RESULT= new Express(a,"||",b);
				// RESULT  =  new Express();
				// RESULT.code = a.code+""+b.code+RESULT.address+"="+a.address+"||"+b.address;
				RESULT.address = Express.Temp();

				:}
				| expression:a AND_OP expression:b
				{:
				RESULT= new Express(a,"&&",b);
				// RESULT  =  new Express();
				// RESULT.code = a.code+""+b.code+RESULT.address+"="+a.address+"&&"+b.address;
				RESULT.address = Express.Temp();

				:}

				| expression:a PLUS expression:b
				{:
				RESULT= new Express(a,"+",b);
				// RESULT  =  new Express();
				// RESULT.code = a.code+""+b.code+RESULT.address+"="+a.address+"+"+b.address;
				RESULT.address = Express.Temp();

				:}
				| expression:a MINUS expression:b
				{:
				RESULT= new Express(a,"-",b);
				// RESULT  =  new Express();
				// RESULT.code = a.code+""+b.code+RESULT.address+"="+a.address+"-"+b.address;
				RESULT.address = Express.Temp();

				:}
				| expression:a ASTRISK expression:b
				{:
				RESULT= new Express(a,"*",b);
				// RESULT  =  new Express();
				// RESULT.code = a.code+""+b.code+RESULT.address+"="+a.address+"*"+b.address;
				RESULT.address = Express.Temp();

				:}
				| expression:a SLASH expression:b
				{:
				RESULT= new Express(a,"/",b);
				// RESULT  =  new Express();
				// RESULT.code = a.code+""+b.code+RESULT.address+"="+a.address+"/"+b.address;
				RESULT.address = Express.Temp();

				:}
				| expression:a PERCENT expression:b
				{:
				RESULT= new Express(a,"%",b);
				// RESULT  =  new Express();
				// RESULT.code = a.code+""+b.code+RESULT.address+"="+a.address+"%"+b.address;
				RESULT.address = Express.Temp();

				:}
				| expression:a SHIFT_LEFT expression:b
				{:
				RESULT= new Express(a,"<<",b);
				// RESULT  =  new Express();
				// RESULT.code = a.code+""+b.code+RESULT.address+"="+a.address+"<<"+b.address;
				RESULT.address = Express.Temp();

				:}
				| expression:a SHIFT_RIGHT expression:b
				{:
				RESULT= new Express(a,">>",b);
				// RESULT  =  new Express();
				// RESULT.code = a.code+""+b.code+RESULT.address+"="+a.address+">>"+b.address;
				RESULT.address = Express.Temp();

				:}
				
				| expression:a AMBERSAND expression:b
				{:
				RESULT= new Express(a,"&",b);
				// RESULT  =  new Express();
				// RESULT.code = a.code+""+b.code+RESULT.address+"="+a.address+"&"+b.address;
				RESULT.address = Express.Temp();

				:}
				| expression:a EXCLAMATION expression:b
				{:
				RESULT= new Express(a,"!",b);
				// RESULT  =  new Express();
				// RESULT.code = a.code+""+b.code+RESULT.address+"="+a.address+"!"+b.address;
				RESULT.address = Express.Temp();

				:};


// Type = TypeName | TypeLit
type	::= typeName:a
			{:
			RESULT = a;
			:}
			| typeLit:b
			{:
			RESULT = b;
			:};

// TypeName = ​identifier
typeName	::=	IDENTIFIER:a
				{:
				RESULT = a;
				:};

// TypeLit = FunctionType
typeLit	::=	functionType:f
			{:
			RESULT = f;
			:};

// FunctionType = ​"func" ​ Signature
functionType	::=	FUNC signature:s
					{:
					RESULT =  s;
					:};

// VarDecl = ​"var" ​ ( VarSpec | ​"(" ​ { VarSpec ​";" ​ } ​")" ​ )
varDecl	::=	VAR varSpec:v 
			{:
			RESULT = v;
			:}
			| VAR OPEN_PARAN varSpec:v CLOSE_PARAN
			{:
			RESULT = "("+v+")";
			:};

// VarSpec = ​identifier ​ ( Type [ ​"=" ​ Expression ] | ​"=" ​ Expression )
varSpec	::= IDENTIFIER:i EQUAL expression:e
			{:
			RESULT = i+"="+e.code;
			:}
			| IDENTIFIER:i type:t
			{:
			RESULT = i+t;
			:}
			| IDENTIFIER:i type:t EQUAL expression:e
			{:
			RESULT = i+t+"="+e.code;
			:};
			


shortVarDecl	::= identifierList	COLON_EQUAL	expression
					{:
					RESULT = "";
					:};


functionDecl	::= FUNC functionName:n function:f
					{:
					RESULT = n+f;
					:}
					| FUNC functionName:n signature:s
					{:
					RESULT = n+s;
					:};

functionName	::= IDENTIFIER:i
					{:
					RESULT = i;
					:};


methodDecl	::= FUNC receiver methodName function
				{:
				RESULT = "";
				:}
				| FUNC receiver methodName signature
				{:
				RESULT = "";
				:};

receiver	::= parameters:p
				{:
				RESULT = p;
				:};

// MethodName = ​identifier
methodName	::=	IDENTIFIER:i
				{:
				RESULT = i;
				:};


unaryExpr	::=	primaryExpr:s
				{:
				RESULT=s;
				:}
				| MINUS unaryExpr:b
				{:
				// RESULT  =  new Express();
				// RESULT.address = Express.Temp();
				// RESULT.code = b.code+""+RESULT.address+"="+"-"+b.address;
				// RESULT ="kkk";
				RESULT ="-"+b;
				:}
				| EXCLAMATION unaryExpr:b
				{:
				RESULT ="!"+b;
				:}
				| ASTRISK unaryExpr:b
				{:
				RESULT ="*"+b;
				:}
				| AMBERSAND unaryExpr:b
				{:
				RESULT ="&"+b;
				:}
				| LESS_DASH unaryExpr:b
				{:
				RESULT ="<-"+b;
				:};

//PrimaryExpr = Operand | PrimaryExpr Selector | PrimaryExpr Arguments .
primaryExpr	::=	operand:o
				{:
				RESULT = o;
				:}
				| primaryExpr:p selector:s
				{:
				RESULT = p+s;
				:}
				| primaryExpr:p arguments:a
				{:
				RESULT = p+a;
				:};



selector	::= DOT IDENTIFIER
				{:
				RESULT = "";
				:};




arguments	::=	OPEN_PARAN CLOSE_PARAN
				{:
				RESULT = "";
				:}
				| OPEN_PARAN expressionList CLOSE_PARAN
				{:
				RESULT = "";
				:}
				| OPEN_PARAN TYPE type COMMA expressionList CLOSE_PARAN
				{:
				RESULT = "";
				:};


// Operand = Literal | OperandName | ​"(" ​ Expression ​")" ​ .
operand	::=	literal:l
			{:
			RESULT = l;
			:}
			| operandName:o
			{:
			RESULT = o;
			:}
			| OPEN_PARAN expression:e CLOSE_PARAN
			{:
			RESULT = "("+ e.code + ")";
			:};

//Literal = BasicLit | FunctionLit
literal	::=	basicLit:b
			{:
			RESULT = b;
			:}
			| functionLit:f
			{:
			RESULT = f;
			:};





// BasicLit = ​int_lit ​ | ​string_lit ​ 
basicLit	::=	INT_LIT:i
				{:
				RESULT = ""+i;
				:}
				| STRING_LIT:s
				{:
				RESULT = s;
				:};

operandName	::=	IDENTIFIER
				{:
				RESULT = "";
				:}
				| qualifiedIdent
				{:
				RESULT = "";
				:};


qualifiedIdent	::=	DOT packageName DOT IDENTIFIER
					{:
					RESULT = "";
					:};
					

// FunctionLit = ​"func" ​ Function .		
functionLit	::=	FUNC function:f
				{:
				RESULT = f;
				:};


// Function = Signature FunctionBody
function	::=	signature:s functionBody:f
				{:
				RESULT = s+f;
				:};

// Signature = Parameters [ Result ]
signature	::=	parameters:p
				{:
				RESULT = p;
				:}
				| parameters:p result:r
				{:
				RESULT = p+r;
				:};

// Result = Parameters | ​"(" ​ Type ​")"
result	::=	parameters:s
			{:
			RESULT = s;
			:}
			| OPEN_PARAN type:b CLOSE_PARAN
			{:
			RESULT = "(" + b + ")";
			:};

// Parameters = ​"(" ​ [ ParameterList ] ​")" ​
parameters	::=	OPEN_PARAN CLOSE_PARAN
				{:
				RESULT = "("+")";
				:}
				| OPEN_PARAN parameterList:p CLOSE_PARAN
				{:
				RESULT = "("+p+")";
				:}; 

// ParameterList = ParameterDecl { ​"," ​ ParameterDecl }
parameterList	::=	parameterDecl:p
					{:
					RESULT = p;
					:}
					| parameterDecl:p COMMA parameterList:l
					{:
					RESULT = p+","+l;
					:};

// ParameterDecl = IdentifierList [ ​"..." ​ ] Type .
parameterDecl	::= identifierList:i type:t
					{:
					RESULT = i+t;
					:}
					| identifierList:i CDOTS type:t
					{:
					RESULT = i+"..."+t;
					:};

// FunctionBody = Block
functionBody	::= block:b
					{:
					RESULT = b;
					:};

// Block = ​"{" ​ StatementList ​"}" ​
block	::= OPEN_CURLY statementList:s CLOSE_CURLY
			{:
			RESULT = "{"+s+"}";
			:};

// StatementList = { Statement }
statementList	::=	statement:s statementList:l
					{:
					RESULT = s+l;
					:}
					| 
					{:
					RESULT = "";
					:};

packageClause	::=	PACKAGE packageName:a
					{:
					RESULT = a;
					:};


importDecls	::=	importDecl optionalSemiColon importDecls
				{:
				RESULT = "";
				:}
				|
				{:
				RESULT = "";
				:};

importDecl	::=	IMPORT	importSpec
				{:
				RESULT = "";
				:}
				| IMPORT OPEN_PARAN importSpecs CLOSE_PARAN
				{:
				RESULT = "";
				:};

importSpecs	::=	importSpec optionalSemiColon importSpecs
				{:
				RESULT = "";
				:}
				| 
				{:
				RESULT = "";
				:};

importSpec	::=	importPath
				{:
				RESULT = "";
				:}
				| DOT importPath
				{:
				RESULT = "";
				:}
				| packageName importPath
				{:
				RESULT = "";
				:};
				
importPath	::=	STRING_LIT
				{:
				RESULT = "";
				:};

packageName	::=	IDENTIFIER:a
				{:
				RESULT = a;
				:};


optionalSemiColon	::=	SEMI_COLON
						{:
						RESULT = ";";
						:}
						| 
						{:
						RESULT = "";
						:};